---
title: "Notes on scheduling the SAA2019 meeting"
author:
  - Ben Marwick
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  tint::tintHtml: 
     self_contained: TRUE
     df_print: paged
---


<!-- This is the format for text comments that will be ignored during renderings. Do not put R code in these comments because it will not be ignored. -->

```{r, setup, echo = FALSE, warning = FALSE, message = FALSE,}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  comment = "#>",
  fig.path = "figures"
)

library(saaabstracts)
library(readxl)
library(tidyverse)
library(knitr)
library(glue)

```
## Introduction

## How many sessions do we have?

```{r}
library(readxl)

gen_poster_session_posters <- read_excel("../data/raw_data/02 - poster_sessions_FINAL(oct31).xlsx")

org_poster_sessions_only <- read_excel("../data/raw_data/02 - poster_sessions_FINAL(oct31).xlsx", sheet = "ORGANIZED_POSTER_SESSION_SIZES")

after_hours_poster_sessions_only <- 
  read_excel("../data/raw_data/02 - poster_sessions_FINAL(oct31).xlsx", 
             sheet = "AFTER_HOURS") %>% 
  slice(1:9) %>% 
  mutate(`Session Id` = as.numeric(gsub("\\D", "", ID)))

# In here we have org and after hours posters

all_abstracts  <-  read_excel("../data/raw_data/Organized Session Abstracts_2018_AB.xlsx") 

org_and_after_hours_posters_individual <- 
all_abstracts %>% 
  filter(`Session Type` == "Poster Symposium") %>% 
  filter(Role == "Presenter")

gen_and_org_poster_sessions_only <- 
all_abstracts %>% 
  filter(`Session Type` == "Poster Symposium") %>% 
  filter(Role == "Chair (Primary)") 
  

# how many unique general sessions? 
n_gen_poster_sessions <- length(unique(gen_poster_session_posters$cuts))

# how many unique organised sessions? 
n_org_poster_sessions <- nrow((org_poster_sessions_only))

# how many unique after hours sessions? 
n_ah_poster_sessions <- nrow(after_hours_poster_sessions_only)

# total number of sessions
total_number_of_sessions <-  n_gen_poster_sessions + n_org_poster_sessions + n_ah_poster_sessions

# combine organised and general sessions
gen_poster_session_posters$session <- gen_poster_session_posters$cuts

org_poster_session_posters <- 
  org_and_after_hours_posters_individual %>% 
  mutate(session = `Session Id`) %>% 
  filter(session %in% org_poster_sessions_only$ID) 
  
common_cols <- intersect(names(gen_poster_session_posters),  names(org_poster_session_posters))

gen_poster_session_posters <- 
  gen_poster_session_posters %>% 
  select(common_cols)

org_poster_session_posters <- 
  org_poster_session_posters %>% 
  select(common_cols)

gen_and_org_poster_session_posters <- 
  bind_rows(gen_poster_session_posters, 
            org_poster_session_posters)

# check the number of gen and org poster sessions:
gen_and_org_poster_sessions_only <- 
  gen_and_org_poster_session_posters %>% 
  group_by(session) %>% 
  slice(1)

after_hours_poster_sessions_all_posters <- 
  org_and_after_hours_posters_individual %>% 
  filter(`Session Id` %in% after_hours_poster_sessions_only$`Session Id`) %>% 
  mutate(poster_session_time = "Th-evening")

```

We have `r nrow(n_ah_poster_sessions)` sessions of after-hours posters, for a total of `r nrow(after_hours_poster_sessions_all_posters)` posters.

We have `r nrow(gen_and_org_poster_sessions_only)` sessions of general and organised session posters, for a total of `r nrow(gen_and_org_poster_session_posters)` posters.

We have from the SAA information about how many posters can go into each session

```{r}
# poster session durations
library(stringi)
poster_session_durations <- 
  read_excel("../data/raw_data/saa all organizedsession_timeslotABv3.xls", 
             sheet = "Posters1")

# add day-part to compare with papers
poster_session_durations <- 
  poster_session_durations %>% 
  mutate(start = as.character(start)) %>% 
  mutate(end = as.character(end)) %>% 
  mutate(day_part = case_when(
    start == "1899-12-31 08:00:00" ~ "morning",
    start == "1899-12-31 10:30:00" ~ "morning",
    start == "1899-12-31 14:00:00" ~ "afternoon",
    start == "1899-12-31 17:00:00" ~ "evening"
  )) %>% 
  mutate(day_part = glue('{stri_trans_totitle(substr(day, 1, 2))}-{day_part}'))

poster_session_durations
```

There are spaces for a total of `r sum(poster_session_durations$'N max')` posters. We have received `r nrow(gen_and_org_poster_session_posters)` poster submissions. So we have `r nrow(gen_and_org_poster_session_posters) - sum(poster_session_durations$'N max')` more posters than available spaces. 

Thu-evening is the 'after hours' session, so that's already got the after-hours poster sessions in there. We'll just omit it from the following, and we don't need to worry about clashes because it's after all the papers. 100 posters are permitted in the after-hours session. 

```{r}
# exclude Thurs evening from now on
poster_session_durations <- 
  poster_session_durations %>% 
  filter(day_part != "Th-evening")

# put out the after hours sessions and posters in a CSV
write_csv(after_hours_poster_sessions_all_posters,
          "../data/derived_data/after_hours_poster_sessions_all_posters.csv")

# Make sure that we don't have the Thu-evening posters in the remaining posterings
gen_and_org_poster_sessions_only$session[gen_and_org_poster_sessions_only$session %in% after_hours_poster_sessions_all_posters$`Session Id`] 
```

We have `r nrow(after_hours_poster_sessions_all_posters)` posters in the after hours session. That's `r ifelse(nrow(after_hours_poster_sessions_all_posters) <= 100, "great", "not ideal")`.

We want to avoid people giving a poster and a talk at the same time, so we need to check with the paper schedule:

```{r}
sessions_in_day_parts_data_with_all_names_df <- 
  read_csv("../data/derived_data/sessions_in_day_parts_data_with_all_names_df.csv")
```

Now we need to put the poster sessions into the remaining slots while checking to see if one of the poster authors is already scheduled to give a paper.

```{r}
# prepare sessions we have
  poster_session_durations_summary <- 
    poster_session_durations %>% 
    group_by(day_part) %>% 
    summarise(`N max` = sum(`N max`))
  
  # make a unique value for names
  gen_and_org_poster_sessions_only <- 
  gen_and_org_poster_sessions_only %>% 
    mutate(uid = glue('{`First Name`}_{`Last Name`}'))
  
  gen_and_org_poster_session_posters <- 
    gen_and_org_poster_session_posters %>% 
    mutate(uid = glue('{`First Name`}_{`Last Name`}'))
  
  # we're going to change these
  gen_and_org_poster_sessions_only_tmp <- gen_and_org_poster_sessions_only
  container_for_this_day_part <- 0
  poster_session_durations_summary$numbers_of_posters <- 0
  poster_session_durations_summary$n_posters <- 0
  poster_session_durations_summary$n_sessions <- 0
  poster_session_durations_summary$c_sessions <- 0
  poster_session_durations_summary$c_posters <- 0
  all_of_the_day_parts <- 0
  i <- 1

# loop over each day-slot available for poster sessions
for(i in seq_len(nrow(poster_session_durations_summary))) {
  
    # stop loop gracefully when we have assigned all people to day-parts
  if (nrow(gen_and_org_poster_sessions_only_tmp) == 0){ break }
  
    # how many rows (posters) to we have remaning to allocate to a day-part?
  print(glue('number of poster sessions remaining to classify is {nrow(gen_and_org_poster_sessions_only_tmp)}'))
  
  # need a buffer
  buffer <- 3
  target_capacity <- poster_session_durations_summary$`N max`[i] - buffer
  
  # prepare variables for the next round, just to be sure
  cumulative_number_of_posters <- 0
  container_for_this_day_part <- 0
  this_session_posters <- 0
  j <- 1
  
  while(cumulative_number_of_posters <= target_capacity & j <= nrow(gen_and_org_poster_sessions_only_tmp)){
  
  # get a session 
  this_session <- gen_and_org_poster_sessions_only[j, ]
  
  # get names for all the people in this poster session
  this_session_posters <- 
    gen_and_org_poster_session_posters %>% 
      filter(session == this_session$session)
  
#-------------------------------------------------------------------  
  # check to see if these names are already in this day-part
  # or in the paper sessions
  if (j == 1){
    
    # do nothing is this is the first incoming session 
    names_already_in <-  0
    names_already_in2 <- 0
    
  } else {
      # get distinct names for each session previously added
      # to this day-part
      # (don't care about same name multiple times in one session)
      distinct_names_for_each_session_so_far <- 
      container_for_this_day_part %>% 
        group_by(uid) %>% 
        distinct(uid, .keep_all = TRUE) %>% 
        pull(uid)
      
      # check to see if incoming session has 
      # names that already exist in this day_part
      names_already_in <- sum(this_session_posters$uid %in% distinct_names_for_each_session_so_far)
      
      # check to see if papers for this day-part already have the name in it
      names_papers_in_this_day_part <- 
        sessions_in_day_parts_data_with_all_names_df %>% 
        filter(day_part_from_while.y == poster_session_durations_summary[i,]$day_part) %>% 
        pull(uid.y)
      
      names_already_in2 <- sum(this_session_posters$uid %in% names_papers_in_this_day_part)
  
  }

#-------------------------------------------------------------------
    # if there are no name conflicts, then
    # accumulate the incoming session onto the sessions
    # we've already added to this day-part
  
    if (j == 1) {
      
       container_for_this_day_part <- 
        this_session_posters
       
      } else {
      if (names_already_in == 0 & names_already_in2 == 0) {
        
      # if there are no name clashes, 
      # add these names to previous names in this day-part
      # bind rows of session that has no clashing  names with 
      # sessions we already added to this day-part
      container_for_this_day_part <- 
        bind_rows(this_session_posters,
                  container_for_this_day_part)
      
    }  else {
      
      # do not add this session to the day-part 
      # because at least one of the names is already in there
      }
      }
  
#-------------------------------------------------------------------  
  # compute the number of posters we've added to this day-part
  # by counting the abstract Id, because this excludes the session chairs
    cumulative_number_of_posters <- 
      length(!is.na(container_for_this_day_part$`Abstract Id`))
  
   # store this result
    poster_session_durations_summary$numbers_of_posters[i] <- cumulative_number_of_posters
    
    print(glue('cumulative number of posters: {cumulative_number_of_posters}, j = {j}, i = {i}'))
  
  # go to next session
  j <- j + 1
  }
  # end of while loop
  
   # add an identifier so we can see where we have assigned each session so far
 container_for_this_day_part_with_session_from_while <- 
   container_for_this_day_part %>% 
   mutate(day_part_from_while  = as.character(poster_session_durations_summary$day_part[i]))
 
 # bind rows to previous day-parts we might have done
  if (i == 1) {
 
  all_of_the_day_parts <- container_for_this_day_part_with_session_from_while
 
  } else {
    
    # check to see
    
  all_of_the_day_parts <- bind_rows(container_for_this_day_part_with_session_from_while, 
                                      all_of_the_day_parts)
  }
 
  poster_session_durations_summary$n_posters[i] <- length(unique(container_for_this_day_part_with_session_from_while$`Abstract Id`))
  
 poster_session_durations_summary$n_sessions[i] <- length(unique(container_for_this_day_part_with_session_from_while$session))
 
 poster_session_durations_summary$c_sessions[i] <-  sum(poster_session_durations_summary$n_sessions)
 poster_session_durations_summary$c_posters[i] <-  sum(poster_session_durations_summary$n_posters)

 print(poster_session_durations_summary %>% select(`N max`, 
                                                   day_part,
                                                   n_posters,
                                                   n_sessions, 
                                                   c_sessions,
                                                   c_posters))

 # for the next day-part, we need to make sure
 # we don't add the same session twice to different day-parts
 # so let's update our big table of posters, and drop the session that 
 # we've already got in the day-part

gen_and_org_poster_sessions_only_tmp <-  
   gen_and_org_poster_sessions_only_tmp %>% 
   filter(! session %in% unique(container_for_this_day_part$session))

}
# end of for loop

# out put the results
write.csv(all_of_the_day_parts, 
          "../data/derived_data/posters_output_of_session_classification.csv")

write.csv(poster_session_durations_summary, "../data/derived_data/poster_session_durations.csv")
```

Seems that we have too many posters for the available space. Let's double-check:

```{r}
# duplicates?
all_of_the_day_parts %>% 
  distinct()

# why is each poster in each day-part?
all_of_the_day_parts %>% 
 arrange(uid) %>% View


# how many abstracts
posters_with_abstract_ids <- 
all_of_the_day_parts %>% 
  filter(!is.na(`Abstract Id`)) %>% 
  group_by(day_part_from_while) %>% 
  tally() %>% 
  summarise(sum(n)) %>% 
  pull()
```

We have `r posters_with_abstract_ids` posters with Abstract IDs (and so not chair/co-chairs). Compare to `r nrow(gen_and_org_poster_session_posters)` posters that we started with, and space available for `r sum(poster_session_durations$'N max')` posters. 


What do we stil need to do?

- Posters 


### Colophon

This report was generated on `r Sys.time()` using the following computational environment and dependencies: 

```{r colophon, cache = FALSE}
# which R packages and versions?
devtools::session_info()
```

The current Git commit details are:

```{r}
# what commit is this file at? 
git2r::repository("../..")
```

